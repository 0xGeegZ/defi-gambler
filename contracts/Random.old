// pragma solidity ^0.6.12;

// /*
// #    Copyright (C) 2017  alianse777
// #    This program is free software: you can redistribute it and/or modify
// #    it under the terms of the GNU General Public License as published by
// #    the Free Software Foundation, either version 3 of the License, or
// #    (at your option) any later version.
// #
// #    This program is distributed in the hope that it will be useful,
// #    but WITHOUT ANY WARRANTY; without even the implied warranty of
// #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// #    GNU General Public License for more details.
// #
// #    You should have received a copy of the GNU General Public License
// #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
// */

// /* "random" numbers generator (not cryptographicaly secure)
//    rand(uint seed) - returns random number generated by seed
//    randint() - returns random number with current time as seed
//    randbytes(uint size) - returns byte array of random bytes
// */

// contract Random {
//     /**
//      * @dev Generate random uint <= 256^2
//      * @param seed
//      * @return uint
//      */
//     function rand(uint256 seed) internal pure returns (uint256) {
//         bytes32 data;
//         if (seed % 2 == 0) {
//             data = keccak256(bytes32(seed));
//         } else {
//             data = keccak256(keccak256(bytes32(seed)));
//         }
//         uint256 sum;
//         for (uint256 i; i < 32; i++) {
//             sum += uint256(data[i]);
//         }
//         return
//             uint256(data[sum % data.length]) *
//             uint256(data[(sum + 2) % data.length]);
//     }

//     /**
//      * @dev Generate random uint <= 256^2 with seed = block.timestamp
//      * @return uint
//      */
//     function randint() internal view returns (uint256) {
//         return rand(now);
//     }

//     /**
//      * @dev Generate random uint in range [a, b]
//      * @return uint
//      */
//     function randrange(uint256 a, uint256 b) internal view returns (uint256) {
//         return a + (randint() % b);
//     }

//     /**
//      * @dev Generate array of random bytes
//      * @param size seed
//      * @return byte[size]
//      */
//     function randbytes(uint256 size, uint256 seed)
//         internal
//         pure
//         returns (byte[] memory)
//     {
//         byte[] memory data = new byte[](size);
//         uint256 x = seed;
//         for (uint256 i; i < size; i++) {
//             x = rand(x);
//             data[i] = byte(x % 256);
//         }
//         return data;
//     }

//     /**
//      * @dev Generate array of random bytes
//      * @param size seed
//      * @return byte[size]
//      */
//     function randbytes(uint256 size) internal pure returns (byte[] memory) {
//         return randbytes(size, now);
//     }

//     /**
//      * @dev Generate array of random bytes
//      * @param size seed
//      * @return byte[size]
//      * https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity
//      */
//     function randbytes() internal pure returns (bytes32) {
//         // b = new bytes(32);
//         // assembly {
//         //     mstore(add(b, 32), x)
//         // }

//         return abi.encodePacked(randint());
//     }
// }
